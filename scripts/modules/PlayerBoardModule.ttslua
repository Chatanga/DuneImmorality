playerBoardModule = {}

i18n = require("i18n")
require("locales")

constants = require("Constants")

helper = require("HelperModule")

parkModule = require("ParkModule")

playerBoardModule.playerColor = nil

playerBoardModule.orbitZone = nil

playerBoardModule.orbitPark = nil

playerBoardModule.score = 0

playerBoardModule.self_score_positions = {}

playerBoardModule.scoreboardZone = nil

playerBoardModule.scorePark = nil

playerBoardModule.techPark = nil

playerBoardModule.alive = true

function playerBoardModule.init(playerColor, centerPosition, savedData)
    self.interactable = false

    playerBoardModule.playerColor = playerColor

    if savedData ~= '' then
        local state = JSON.decode(savedData)
        playerBoardModule.orbitZone = getObjectFromGUID(state.orbitZoneGUID)
        playerBoardModule.scoreboardZone = getObjectFromGUID(state.scoreboardZoneGUID)
        playerBoardModule.alive = state.alive
    end

    if not playerBoardModule.alive then
        return
    end

    playerBoardModule.orbitPark = playerBoardModule.createOrbitPark(centerPosition)
    playerBoardModule.techPark = playerBoardModule.createTechPark(centerPosition)

    playerBoardModule.createButtons()

    playerBoardModule.initPlayerScore()

    playerBoardModule.saveState()
end

function playerBoardModule.saveState()
    local state = {
        orbitZoneGUID = playerBoardModule.orbitZone.getGUID(),
        scoreboardZoneGUID = playerBoardModule.scoreboardZone.getGUID(),
        alive = playerBoardModule.alive
    }
    self.script_state = JSON.encode(state)
end

function getOrbitPark()
    return playerBoardModule.orbitPark
end

function getTechPark()
    return playerBoardModule.techPark
end

function getScorePark()
    return playerBoardModule.scorePark
end

function getScore()
    return playerBoardModule.score
end

function shutdown(parameters)
    local riseOfIxEnabled = parameters[1] == 1
    local immortalityEnabled = parameters[2] == 1
    playerBoardModule.shutdown(riseOfIxEnabled, immortalityEnabled)
end

function playerBoardModule.createOrbitPark(centerPosition)
    local allSlots = {}
    local slots = {}
    for i = 1, 4 do
        for j = 1, 4 do
            local x = (i - 2.5) * 0.5
            local z = (j - 2.5) * 0.5
            local slot = Vector(x, 0.29, z):rotateOver('y', -45) + centerPosition
            allSlots[#allSlots + 1] = slot
            if i < 3 or j < 3 then
                slots[#slots + 1] = slot
            end
        end
    end

    if not playerBoardModule.orbitZone then
        playerBoardModule.orbitZone = parkModule.findBoundingZone(45, Vector(0.35, 0.35, 0.35), allSlots)

        for i, troop in ipairs(constants.players[playerBoardModule.playerColor].troops) do
            troop.locked = true
            troop.setPosition(slots[i])
            troop.setRotation(Vector(0, 45, 0))
        end
    end

    return parkModule.createPark(
        "orbit." .. playerBoardModule.playerColor,
        slots,
        Vector(0, -45, 0),
        playerBoardModule.orbitZone,
        playerBoardModule.playerColor,
        playerBoardModule.playerColor,
        true)
end

function playerBoardModule.createTechPark(centerPosition)

    local color = playerBoardModule.playerColor
    local slots = {}
    for i = 1, 2 do
        for j = 3, 1, -1 do
            local x = (i - 1.5) * 3 + 6
            if color == "Red" or color == "Blue" then
                x = -x
            end
                local z = (j - 2) * 2 + 0.4
            local slot = Vector(x, 0.29, z) + centerPosition
            slots[#slots + 1] = slot
        end
    end

    return parkModule.createPark(
        "tech." .. playerBoardModule.playerColor,
        slots,
        Vector(0, 180, 0),
        constants.players[playerBoardModule.playerColor].techZone,
        nil,
        "Tech",
        false)
end

function playerBoardModule.initPlayerScore()
    playerBoardModule.generateselfScoreboardPositions()
    playerBoardModule.scorePark = playerBoardModule.createPlayerScoreboardPark()
    playerBoardModule.updatePlayerScore()
end

function playerBoardModule.generateselfScoreboardPositions()
    local origin = constants.players[playerBoardModule.playerColor].score_marker.getPosition()

    -- Avoid collision between markers by giving a different height to each.
    local h = 1
    for color, _ in pairs(constants.players) do
        if color == playerBoardModule.playerColor then
            break
        else
            h = h + 0.5
        end
    end

    playerBoardModule.self_score_positions = {}
    for i = 1, 14 do
        playerBoardModule.self_score_positions[i] = {
            origin.x,
            2.7 + h,
            origin.z + (i - 2) * 1.165
        }
    end
end

function playerBoardModule.createPlayerScoreboardPark()
    local origin = constants.players[playerBoardModule.playerColor].vp_4_players_token_initial_position

    local direction = 1
    if playerBoardModule.playerColor == "Red" or  playerBoardModule.playerColor == "Blue" then
        direction = -1
    end

    local slots = {}
    for i = 0, 17 do
        slots[i + 1] = Vector(
            origin.x + i * 1.092 * direction,
            origin.y,
            origin.z)
    end

    if not playerBoardModule.scoreboardZone then
        playerBoardModule.scoreboardZone = parkModule.findBoundingZone(0, Vector(0.6, 0.2, 0.6), slots)
    end

    return parkModule.createPark(
        "scoreboard." .. playerBoardModule.playerColor,
        slots,
        Vector(0, 180, 0),
        playerBoardModule.scoreboardZone,
        nil,
        "VP",
        false)
end

function playerBoardModule.updatePlayerScore()
    local zoneObjects = playerBoardModule.scoreboardZone.getObjects()
    local newScore = 0
    for _, object in ipairs(zoneObjects) do
        if object.getDescription() == "VP" then
            newScore = newScore + 1
        end
    end

    local vpIndex = math.min(14, newScore + 1)
    local score_marker = constants.players[playerBoardModule.playerColor].score_marker
    score_marker.setPositionSmooth(playerBoardModule.self_score_positions[vpIndex])
    score_marker.setRotationSmooth({0, 0, 0}, false, false)

    if newScore ~= playerBoardModule.score then
        playerBoardModule.score = newScore
        local setup = getObjectFromGUID("4a3e76")
        setup.call("updateScores")
    end
end

function onObjectEnterScriptingZone(zone, enter_object)
    if playerBoardModule.alive then
        if zone.guid == playerBoardModule.scoreboardZone.guid then
            local description = enter_object.getDescription()
            if description == "VP" then
                playerBoardModule.updatePlayerScore()
            end
        end
    end
end

function onObjectLeaveScriptingZone(zone, enter_object)
    if playerBoardModule.alive then
        if zone.guid == playerBoardModule.scoreboardZone.guid then
            local description = enter_object.getDescription()
            if description == "VP" then
                playerBoardModule.updatePlayerScore()
            end
        end
    end
end

function playerBoardModule.shutdown(riseOfIxEnabled, immortalityEnabled)
    playerBoardModule.alive = false
    playerBoardModule.saveState()

    local player = constants.players[playerBoardModule.playerColor]

    local toBeRemoved = {
        player.swordmaster,
        player.council_token,
        -- player.vp_4_players_token,
        player.score_marker,
        player.flag_bag,
        player.marker_combat
    }

    if riseOfIxEnabled then
        playerBoardModule.addAll(toBeRemoved, player.dreadnoughts)
        toBeRemoved[#toBeRemoved + 1] = player.cargo
    end

    if immortalityEnabled then
        toBeRemoved[#toBeRemoved + 1] = player.tleilaxuTokens
        toBeRemoved[#toBeRemoved + 1] = player.researchTokens
    end

    playerBoardModule.addAll(toBeRemoved, player.agents)
    playerBoardModule.addAll(toBeRemoved, player.troops)

    for _, object in ipairs(toBeRemoved) do
        if toBeRemoved then
            object.interactable = true
            object.destruct()
        end
    end
end

function playerBoardModule.addAll(objects, otherObjects)
    assert(objects)
    assert(otherObjects)
    for _, object in ipairs(otherObjects) do
        objects[#objects + 1] = object
    end
end

function onPlayerTurn(player, previous_player)
    --[[
    -- Illumine le plateau du joueur dont c’est le tour (et éteint les autres).
    local indexed_colors = {"Green", "Yellow", "Blue", "Red"}
    for i, color in ipairs(indexed_colors) do
        local effect_index = 0 -- black index (no color actually)
        if player and player.color == color then
            effect_index = i
        end
        local board = constants.players[color].board
        board.AssetBundle.playTriggerEffect(effect_index)
    end
    ]]--

    local effect_index = 0 -- black index (no color actually)
    if player and player.color == playerBoardModule.playerColor then
        local indexed_colors = {
            Green = 1,
            Yellow = 2,
            Blue = 3,
            Red = 4
        }
        effect_index = indexed_colors[playerBoardModule.playerColor]
    end
    self.AssetBundle.playTriggerEffect(effect_index)
end

function playerBoardModule.createButtons()
    local font_color = nil
    if playerBoardModule.playerColor == 'Yellow' then
        font_color = {0.1, 0.1, 0.1, 1}
    else
        font_color = {0.9, 0.9, 0.9, 1}
    end

    self.createButton({
        click_function = "reveal",
        function_owner = self,
        label = i18n("revealButton"),
        position = new_symmetric_board_position(-14.8, 0, -5),
        rotation = new_symmetric_board_rotation(0, -90, 0),
        width = 1600,
        height = 320,
        font_size = 280,
        color = playerBoardModule.playerColor,
        font_color = font_color
    })
    self.createButton({
        click_function = "resetDiscard",
        function_owner = self,
        label = i18n("resetDiscardButton"),
        position = new_offseted_board_position(-3.5, 0, 2.6),
        width = 1200,
        height = 250,
        font_size = 150,
        color = playerBoardModule.playerColor,
        font_color = font_color
    })
    self.createButton({
        click_function = "drawFive",
        function_owner = self,
        label = i18n("drawFiveButton"),
        position = new_offseted_board_position(-13.5, 0, 2.6),
        width = 1400,
        height = 250,
        font_size = 150,
        color = playerBoardModule.playerColor,
        font_color = font_color
    })
    self.createButton({
        click_function = "drawOneCard",
        function_owner = self,
        label = i18n("drawOneCardButton"),
        position = new_offseted_board_position(-13.5, 0, 1.8),
        width = 1100,
        height = 250,
        font_size = 150,
        color = playerBoardModule.playerColor,
        font_color = font_color
    })

    self.createButton({
        click_function = "doNothing",
        function_owner = self,
        label = i18n("agentTurn"),
        position = new_symmetric_board_position(-14.8, 0, -1),
        rotation = new_symmetric_board_rotation(0, -90, 0),
        width = 0,
        height = 0,
        font_size = 280,
        color = {0,0,0,1},
        font_color = playerBoardModule.playerColor
    })
end

function playerBoardModule.drawOneCardColor(color)
    if color == playerBoardModule.playerColor then
        constants.players[color].board.clearButtons()
        Wait.time(function() activateButtons(color) end, 0.3)
        helper.drawOneCard(_, color)
    else
        broadcastToColor(i18n('noTouch'), color, "Purple")
    end
end

function playerBoardModule.createPassButton()
    local player = constants.players[playerBoardModule.playerColor]

    local reparentingOffset = player.board.getPosition() - player.pass_turn_anchors.getPosition()
    reparentingOffset:setAt('z', -reparentingOffset.z) -- 180° orientation...
    local position = new_symmetric_board_position(-3.5, 0, 8.2) + reparentingOffset

    player.pass_turn_anchors.createButton({
        click_function = "passTurn",
        function_owner = self,
        label = i18n("passButton"),
        position = position,
        width = 1375,
        height = 1000,
        font_size = 400,
        color = "Purple",
        font_color = {0.9, 0.9, 0.9, 1}
    })
end

function resetDiscard(color)
    if color == playerBoardModule.playerColor then
        constants.players[color].board.clearButtons()
        Wait.time(function() activateButtons(color) end, 1)
        helper.resetDiscard(_, color)
    else
        broadcastToColor(i18n('noTouch'), color, "Purple")
    end
end

function playerBoardModule.revealEarly(color)
    local direction = -1
    if color == 'Blue' or color == "Red" then
        direction = 1
    end

    self.createButton({
        click_function = 'doNothing',
        label = i18n("revealEarlyConfirm"),
        function_owner = self,
        position = Vector(8 * direction, 0.7, 4.5),
        width = 0,
        height = 0,
        scale = {0.5, 0.5, 0.5},
        font_size = 500,
        font_color = color,
        color = {0, 0, 0, 1}
    })
    self.createButton({
        click_function = 'validateReveal',
        label = i18n('yes'),
        function_owner = self,
        position = Vector(8 * direction - 1, 0.7, 5.5),
        width = 1000,
        height = 600,
        scale = {0.5, 0.5, 0.5},
        font_size = 500,
        font_color = {1, 1, 1},
        color = "Green"
    })
    self.createButton({
        click_function = 'cancelChoice',
        label = i18n('no'),
        function_owner = self,
        position = Vector(8 * direction + 1, 0.7, 5.5),
        width = 1000,
        height = 600,
        scale = {0.5, 0.5, 0.5},
        font_size = 500,
        font_color = {1, 1, 1},
        color = "Red"
    })
end

function doNothing() end

function cancelChoice(color)
    if color == playerBoardModule.playerColor then
        self.clearButtons()
        activateButtons(color)
    else
        broadcastToColor(i18n('noTouch'), color, "Purple")
    end
end

function reveal(color)
    if color == playerBoardModule.playerColor then
        local players = getObjectFromGUID("4a3e76").call("getPlayersBasedOnHotseat")
        local turnColor = nil
        if getObjectFromGUID("4a3e76").getVar("hotseat_mode") then
            turnColor = Player.getPlayers()[1].color
        else
            turnColor = Turns.turn_color
        end
        if turnColor ~= color and #players > 1 then
            broadcastToColor(i18n("revealNotTurn"), color, "Pink")
        elseif playerBoardModule.stillHavePlayableAgents(color) then
            playerBoardModule.revealEarly(color)
        else
            playerBoardModule.doReveal(_, color)
        end
    else
        broadcastToColor(i18n('noTouch'), color, "Purple")
    end
end

function playerBoardModule.doReveal(_, color)
    self.clearButtons()
    Wait.time(function() activateButtons(color) end, 2)

    --log("Player[" .. color .. "].getHandObjects() = " .. tostring(Player[color].getHandObjects()))
    local count = 0
    local c = 0
    local d = 0

    local dir = nil
    if color == "Yellow" or color == "Green" then
        dir = 1
    elseif color == "Red" or color == "Blue" then
        dir = -1
    else
        assert(false)
    end


    local pos_reveal = {
        Red = constants.players["Red"].board.getPosition() + Vector(13, 0.69, -5),
        Blue = constants.players["Blue"].board.getPosition() + Vector(13, 0.69, -5),
        Green = constants.players["Green"].board.getPosition() + Vector(-13, 0.69, -5),
        Yellow = constants.players["Yellow"].board.getPosition() + Vector(-13, 0.69, -5)
    }

    local t = 0
    for _, object in ipairs(Player[color].getHandObjects()) do
        if object.hasTag('Imperium') then
            Wait.time(function()
                if count < 10 then
                    object.setPosition({
                        pos_reveal[color][1] + c,
                        1.8,
                        pos_reveal[color][3] + d
                    })
                    c = c + 2.5 * dir
                    count = count + 1
                end
            end, t)
            t = t + 0.25
        end
    end

    Wait.time(function()
        state.reveal[color] = true
        -- TableTurnPlayers()
        Turns.enable = false
        local players = getObjectFromGUID("4a3e76").call("getPlayersBasedOnHotseat")
        if #players > 1 then
            activatePass(color)
        end
    end, 1)
end

-- TODO Include Holtzman effect here.
function drawFive(color)
    if color == playerBoardModule.playerColor then
        self.clearButtons()
        Wait.time(function() activateButtons(color) end, 1)

        helper.drawCards(color, constants.players[color].drawDeckZone, 5)
    else
        broadcastToColor(i18n('noTouch'), color, "Purple")
    end
end

function playerBoardModule.stillHavePlayableAgents(color)
    for _, object in ipairs(constants.players[color].zone_player.getObjects()) do
        if object.hasTag("Agent") then
            return true
        end
    end
    return false
end

function new_board_position(x, y, z)
    return Vector(x, y + 0.7, -z)
end

function new_symmetric_board_position(x, y, z)
    if playerBoardModule.playerColor == "Red" or playerBoardModule.playerColor == "Blue" then
        return new_board_position(-x, y, z)
    else
        return new_board_position(x, y, z)
    end
end

function new_symmetric_board_rotation(x, y, z)
    if playerBoardModule.playerColor == "Red" or playerBoardModule.playerColor == "Blue" then
        return new_board_position(x, -y, z)
    else
        return new_board_position(x, y, z)
    end
end

function new_offseted_board_position(x, y, z)
    if playerBoardModule.playerColor == "Red" or playerBoardModule.playerColor == "Blue" then
        return new_board_position(17 + x, y, z)
    else
        return new_board_position(x, y, z)
    end
end

return playerBoardModule
