local parkModule = {}

--[[
    A park is basically an open field bag with a fixed size and a visual
    arrangement of its content. A park content is determined at each operation
    (usually implying a tidy up on the way), so beware of the asynchronous
    moves from park to park.

    slots: the slot positions.
    rotation: the optional rotation to apply to parked objects.
    zone: a zone to test if an object is in the park.
    tag: an optional restriction on the park content.
    locked: should the park content be locked?
]]--
function parkModule.createPark(slots, rotation, zone, tag, locked)
    assert(#slots > 0, "No slot provided for new park.")
    assert(zone, "No park zone provided.")

    -- Check all slots in the zone.

    return {
        slots = slots,
        rotation = rotation,
        zone = zone,
        tag = tag,
        locked = locked
    }
end

--[[
    Transfert objects from a park to another. Beware that moves are asynchronous.

    n: the number of objects to be transfered.
    fromParkName: the source park.
    toParkName: the destination park.
]]--
function parkModule.transfert(n, fromPark, toPark)
    assert(n >= 0, "Negative count.")
    assert(fromPark, "No source park.")
    assert(toPark, "No destination park.")
    assert(fromPark ~= toPark, "Source and destination parks are the same.")

    --[[
        Park objects usually come from other object (one of them at least). As
        such, it shall not be assigned (it is treated as a pure right value).
        Copies must be made when needed (even for temporarily storing it).
    ]]--

    parkModule.instantTidyUp(toPark)

    local objects = parkModule.getObjects(fromPark)
    local emptySlots = parkModule.findEmptySlots(toPark)

    local count = math.min(n, math.min(n, #objects), #emptySlots)

    for i = 1, count do
        parkModule.moveObjectToPark(objects[i], emptySlots[i], toPark)
    end

    return count
end

--[[
    Put an external object in a park, provided it remains a free slot.
    object: the object to put in the park.
    toParkName: the name of the destination park.
]]--
function parkModule.put(object, toPark)
    assert(object, "No object provided.")
    assert(toPark, "No destination park.")

    parkModule.instantTidyUp(toPark)

    local emptySlots = parkModule.findEmptySlots(toPark)
    if #emptySlots >= 0 then
        parkModule.moveObjectToPark(object, emptySlots[0], toPark)
        return true
    else
        return false
    end
end

function parkModule.instantTidyUp(park)

    local freeSlots = {}
    local freeSlotCount = 0
    for _, slot in ipairs(park.slots) do
        freeSlots[slot:copy()] = {}
        freeSlotCount = freeSlotCount + 1
    end

    local freeObjects = {}
    local freeObjectCount = 0
    for _, object in ipairs(parkModule.getObjects(park)) do
        freeObjects[object] = true
        freeObjectCount = freeObjectCount + 1
    end

    while freeSlotCount > 0 and freeObjectCount > 0 do

        for object, _ in pairs(freeObjects) do
            local nearestSqrtDistance = 0
            local nearestCandidates = nil
            for slot, candidates in pairs(freeSlots) do
                if candidates then
                    local sqrtDistance = Vector.sqrDistance(slot, object.getPosition())
                    if not nearestCandidates or sqrtDistance < nearestSqrtDistance then
                        nearestSqrtDistance = sqrtDistance
                        nearestCandidates = candidates
                    end
                end
            end
            assert(nearestCandidates)
            nearestCandidates[object] = nearestSqrtDistance
        end

        for slot, candidates in pairs(freeSlots) do
            local nearestSqrtDistance = 0
            local nearestObject = nil
            for object, sqrtDistance in pairs(candidates) do
                if not nearestObject or sqrtDistance < nearestSqrtDistance then
                    nearestSqrtDistance = sqrtDistance
                    nearestObject = object
                end
            end
            if nearestObject then
                freeSlots[slot] = nil
                freeSlotCount = freeSlotCount - 1
                freeObjects[nearestObject] = nil
                freeObjectCount = freeObjectCount - 1

                nearestObject.setPosition(slot)
                nearestObject.setRotation(park.rotation:copy())
                nearestObject.locked = park.locked
            end
        end
    end

    --assert(#freeObjects == 0, "Too many objects.")
end

function parkModule.moveObjectToPark(object, slot, park)
    object.setPositionSmooth(slot + Vector(0, 1, 0), false, false)
    if park.rotation then
        object.setRotation(park.rotation:copy())
    end
    object.locked = park.locked
end

function parkModule.getObjects(park)
    local objects = {}
    for _, object in ipairs(park.zone.getObjects()) do
        if not park.tag or (object.hasTag(park.tag) and object.getDescription() == park.tag) then
            objects[#objects + 1] = object
        end
    end
    return objects
end

function parkModule.findEmptySlots(park)
    local freeSlots = parkModule.deep_copy(park.slots)

    for _, object in ipairs(parkModule.getObjects(park)) do
        for i, slot in ipairs(freeSlots) do
            if Vector.sqrDistance(slot, object.getPosition()) < 0.1 then
                table.remove(freeSlots, i)
                break
            end
        end
        if #freeSlots == 0 then
            break
        end
    end

    return freeSlots
end

function parkModule.shallow_copy(c)
    local copy = {}
    for i, e in ipairs(c) do
        copy[i] = e
    end
    return copy
end

function parkModule.deep_copy(c)
    local copy = {}
    for i, e in ipairs(c) do
        copy[i] = e:copy()
    end
    return copy
end

function parkModule.findBoundingZone(rotationAroundY, margins, points)
    assert(#points > 0)

    local barycenter = nil
    for _, slot in ipairs(points) do
        assert(slot)
        if barycenter then
            barycenter = barycenter + slot
        else
            barycenter = slot:copy()
        end
    end
    barycenter = barycenter * (1.0 / #points)

    local minBounds = nil
    local maxBounds = nil
    for i, slot in ipairs(points) do
        local transformedSlot = (slot:copy() - barycenter):rotateOver('y', -rotationAroundY)
        if i > 1 then
            minBounds.x = math.min(minBounds.x, transformedSlot.x)
            minBounds.y = math.min(minBounds.y, transformedSlot.y)
            minBounds.z = math.min(minBounds.z, transformedSlot.z)
            maxBounds.x = math.max(maxBounds.x, transformedSlot.x)
            maxBounds.y = math.max(maxBounds.y, transformedSlot.y)
            maxBounds.z = math.max(maxBounds.z, transformedSlot.z)
        else
            minBounds = transformedSlot:copy()
            maxBounds = transformedSlot:copy()
        end
    end

    local sx = 2 * math.max(math.abs(minBounds.x), math.abs(maxBounds.x))
    local sy = 2 * math.max(math.abs(minBounds.y), math.abs(maxBounds.y))
    local sz = 2 * math.max(math.abs(minBounds.z), math.abs(maxBounds.z))

    local zone = spawnObject({
        type= 'ScriptingTrigger',
        position = barycenter,
        rotation = Vector(0, rotationAroundY, 0),
        scale = {
            math.max(1, sx + margins.x),
            math.max(1, sy + margins.y),
            math.max(1, sz + margins.z)}
    })

    return zone
end

return parkModule
