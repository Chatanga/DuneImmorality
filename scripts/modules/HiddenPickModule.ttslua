hiddenPickModule = {}

constants = require("Constants")

helper = require("HelperModule")

parkModule = require("ParkModule")

-- parameter to set
waitTimeUntilBanDelete = 5 -- How many seconds banned leaders are shown to black, and other player must wait
numberOfBan = 6 -- default number of ban
--
leaderChoices = {} -- Table key:player color, value: GUID of leader picked : to adjust initial leader starting ressources when hidden pick is over
playerOrderToPickHidingStates = {} -- Sequence of value to assign to hidingState in global: anti-clokwise starting from player before first player
hiddenPicksOrderSet = false
leadersBanned = false

minimum_value_ban = 1 -- for number of ban buttons: value when Rise of Ix is by default on
maximum_value_ban = 10

_ = core.registerLoadablePart(function(saved_data)
    initHiddenPick()

    hiddenPicks = 0 -- New: if hidden pick is by default on or off

    -----------------Hidden Picks Var section------------------------
    leaders = constants.leaders

    -- leaders will be manipulated a lot: storing GUID only is a must
    leadersGUID = {
        leaders.yuna.GUID, leaders.hundro.GUID, leaders.memnon.GUID,
        leaders.ariana.GUID, leaders.ilesa.GUID, leaders.armand.GUID,
        leaders.paul.GUID, leaders.leto.GUID, leaders.tessia.GUID,
        leaders.rhombur.GUID, leaders.rabban.GUID, leaders.vladimir.GUID,
        leaders.ilban.GUID, leaders.helena.GUID
    }
end)

function initHiddenPick()
    hidingLeaderScriptingZone = getObjectFromGUID("550f6d") -- Big scripting zone to hide leader in blind pick

    -- This table is used in onObjectEnter and onObjectLeave to make objects invisible during picking phase
    hidingStateTable =
        { -- Must be in global since you can't pass tables with getVar()
            [1] = {"Red", "Blue", "Yellow", "Grey", "White"}, -- 1 = Green picking his leader: make leaders invisible to all other players
            [2] = {"Blue", "Yellow", "Green", "Grey", "White"}, -- 2 = Red picking his leader: make leaders invisible to all other players
            [3] = {"Red", "Yellow", "Green", "Grey", "White"},
            [4] = {"Red", "Blue", "Green", "Grey", "White"},
            [5] = {"Red", "Blue", "Yellow", "Green", "Grey", "White"}, -- 5 = make Leader invisible to all: this is during leader random ban, Important: Black cannot be set invisible and will see bans
            [6] = {} -- 6 = make Leader visible to all: after picking process, for players to see unpicked leaders
        }
    hidingState = 0 -- used as index for hidingStateTable
end

-----------------Number of ban buttons section------------------------

function addOne()
    numberOfBan = math.min(numberOfBan + 1, maximum_value_ban)
    updateValue()
end

function minusOne()
    numberOfBan = math.max(numberOfBan - 1, minimum_value_ban)
    updateValue()
end

-----------------New section------------------------


function startPickPlayer()
    getObjectFromGUID("d84873").setInvisibleTo({})

    startLuaCoroutine(self, 'pick_a_player')
end

function pick_a_player()
    local fullPlayerList = Player.getPlayers()
    local count = 0
    local playerList = {}
    if hotseat_mode then
        playerList = {
            {color = "Blue"}, {color = "Red"}, {color = "Green"},
            {color = "Yellow"}
        }
        count = 4
    else
        for _, player in pairs(fullPlayerList) do
            if player.color == "Blue" or player.color == "Red" or player.color ==
                "Green" or player.color == "Yellow" then
                count = count + 1
                table.insert(playerList, player)
            end
        end
    end

    if count == 0 then
        broadcastToAll(i18n("noPlayers"))
        getObjectFromGUID("d84873").editButton({click_function = 'start'})

    elseif count == 1 then
        broadcastToAll(i18n("useDices"))
        marker.unlock()
        getObjectFromGUID("d84873").destruct()

    else

        local randomNumber = math.random(count)
        for i = 1, 10 do -- Animation d√©bile avec 2 boucles XD
            for index, player in ipairs(playerList) do
                getObjectFromGUID("d84873").editButton({color = player.color})
                wait(3)
            end
        end

        local firstPlayer = playerList[randomNumber]
        local fpColor = firstPlayer.color

        broadcastToAll(i18n('firstPlayerBeginning') .. fpColor .. '!', fpColor)
        if hotseat_mode then Player.getPlayers()[1].changeColor(fpColor) end

        -----------------New section------------------------
        if getObjectFromGUID("4a3e76").getVar("hiddenPicks") == 1 then -- New: First player info necessary to determine leader picks player order
            local colorToPass = {fpColor}
            getObjectFromGUID("4a3e76").call("setPlayerHiddenLeaderPickOrder",
                                             colorToPass)
        end
        -----------------End section------------------------
        if not hotseat_mode then
            Turns.enable = true
            Turns.pass_turns = false
            Turns.turn_color = fpColor
        end
        Global.call("resetRound")
        marker.setPositionSmooth(position_marker[firstPlayer.color], false,
                                 false)
        getObjectFromGUID("d84873").destruct()
    end
    return 1 -- return pour la coroutine
end

function wait(numFrames) for i = 1, numFrames, 1 do coroutine.yield(0) end end

-----------------Setup New functions------------------------

-- called from First Player Picker when set up button is clicked: to find player leader pick order from first player and number of player
function setPlayerHiddenLeaderPickOrder(colorPassed)
    local firstPlayerColor = colorPassed[1]
    local arrayOfColor = {"Green", "Red", "Blue", "Yellow"}
    local arrayOfHidingStates = {1, 2, 3, 4} -- all possible hiding states value during pick phase: see Global
    if numPlayers == 4 then
        local indexFirstToPick = (findAnElementIndexInArray(firstPlayerColor,
                                                            arrayOfColor) %
                                     numPlayers) + 1
        for hiddingState in
            cyclicIterator(indexFirstToPick, arrayOfHidingStates) do -- cyclic iterator use closure to iterate all element of array in order starting from anywhere
            table.insert(playerOrderToPickHidingStates, hiddingState)
        end
        hiddenPicksOrderSet = true
    elseif numPlayers == 3 then
        local missingColor = findMissingElements(arrayOfColor,
                                                 getPlayersBasedOnHotseat())[1]
        for i, color in ipairs(arrayOfColor) do
            if color == missingColor then
                table.remove(arrayOfHidingStates, i)
                table.remove(arrayOfColor, i)
            end
        end
        local indexFirstToPick = (findAnElementIndexInArray(firstPlayerColor,
                                                            arrayOfColor) %
                                     numPlayers) + 1
        for hiddingState in
            cyclicIterator(indexFirstToPick, arrayOfHidingStates) do
            table.insert(playerOrderToPickHidingStates, hiddingState)
        end
        hiddenPicksOrderSet = true
    end
end

--[[
    Not a big fan of this approach. Putting / removing a thing from a bag means
    its script will be reloaded and onLoad / onDestroy will be called. As such,
    only passive objects should be put in bags, not leaders with dedicated
    scripts.
]]--
function moveAllLeadersToRandomizer()
    local t = 0 -- similar to the function setting up tech on the board
    for _, leaderGUID in ipairs(leadersGUID) do
        Wait.time(function()
            leaderRandomizer.putObject(getObjectFromGUID(leaderGUID))
        end, t)
        t = t + 0.18
    end
    hidingStateToPass = {5} -- make leaders invisible to all but Black
    Global.call("setHidingState", hidingStateToPass)
end

function banRandomLeaders()
    broadcastToAll(i18n("hiddenPicksRemoving"):format(numberOfBan), "Orange")
    leaderRandomizer.shuffle()
    local leaderToDeleteTable = {} -- temp storing leader to move after banned showned leader are "destroyed"
    for i = 1, numberOfBan do
        local leaderToDelete = leaderRandomizer.takeObject({
            position = leaderPositions[i],
            rotation = {0, 180, 0},
            smooth = true
        })
        table.insert(leaderToDeleteTable, leaderToDelete)
        removeAnElementInArray(leaderToDelete.guid, leadersGUID) -- update available leader pool
    end

    for i = 1, numberOfBan do -- at first I tried to destroy leader, big mistake as it would make all my leader array nil
        destroyObject(leaderToDeleteTable[i]) -- then i tried storing only guid in leaders, still had errors. Then tried to move them in
        -- fakeDestroy(leaderToDeleteTable[i]) -- trash bag: turns out object in bags loses their GUID.Then, I tried to stack banned leader
    end -- and make them invisible, but black would still see them. Best solution was to stack them
    leadersBanned = true

    --[[Wait.time(function()
        for i = 1, numberOfBan do -- at first I tried to destroy leader, big mistake as it would make all my leader array nil
            destroyObject(leaderToDeleteTable[i])         --then i tried storing only guid in leaders, still had errors. Then tried to move them in
            -- fakeDestroy(leaderToDeleteTable[i]) -- trash bag: turns out object in bags loses their GUID.Then, I tried to stack banned leader
        end -- and make them invisible, but black would still see them. Best solution was to stack them
        leadersBanned = true
    end, -- inside the boardgame manual and lock them. Only asset thick enough to hide tiles. I call
              waitTimeUntilBanDelete -- this the "Hidden Assets" method :) Leader are sill loaded in memory, and GUID still exist.
    )]]
end

--[[function fakeDestroy(objectToDestroy)
    objectToDestroy.clearButtons()
    objectToDestroy.setPosition(baseGameManualPosition)
    objectToDestroy.locked = true
end]]

function replaceLeaders() -- called after ban phase and after player pick a leader
    local numberOfLeaderPicked = getLengthTable(leaderChoices)
    if numberOfLeaderPicked < numPlayers then -- increment hiding state from one
        hidingStateToPass = {
            playerOrderToPickHidingStates[numberOfLeaderPicked + 1]
        }
        Global.call("setHidingState", hidingStateToPass)
        local hidingStateToColorTable = {
            [1] = "Green",
            [2] = "Red",
            [3] = "Blue",
            [4] = "Yellow"
        }
        local color =
            hidingStateToColorTable[playerOrderToPickHidingStates[numberOfLeaderPicked +
                1]]
        broadcastToAll(i18n(color:lower()) .. i18n("hiddenPickingLeader"), color)
    else
        hidingStateToPass = {6} -- no more player to choose
        Global.call("setHidingState", hidingStateToPass)
        broadcastToAll(i18n("hiddenPickOver"))
        if tournament == 1 then worm.firstStep() end
    end
    leaderRandomizer.shuffle()
    for i = 1, #leadersGUID do
        leaderRandomizer.takeObject({
            position = leaderPositions[i],
            rotation = {0, 180, 0},
            smooth = true
        })
    end
end

function updateLeaderChoices(varPassed) -- called from the ClaimLeader in all standards Leaders: keep in memory leader picked
    removeAnElementInArray(varPassed.leaderSelectedGUID, leadersGUID) -- update available leader pool
    for _, leaderGUID in ipairs(leadersGUID) do -- put in randomizer+replace on the table between every leader picks: players still see cursor when other players pick
        local leader = getObjectFromGUID(leaderGUID)
        if leader then
            leaderRandomizer.putObject(leader)
        else
            log("Not reinjecting nil leader " .. leaderGUID)
            log(leadersGUID)
        end
    end
    leaderChoices[varPassed.playerColor] = varPassed.leaderSelectedGUID -- update leader choices
    replaceLeaders()
    assert(numPlayers ~= nil)
    if numPlayers == getLengthTable(leaderChoices) then -- when all player picked: claim chosen Leader if it was a normal game (without hiddenPicks)+make them now visible
        hiddenPicks = 0
        for color, leaderChoiceGUID in pairs(leaderChoices) do
            varToPass = {leaderChoiceGUID = leaderChoiceGUID, color = color}
            getObjectFromGUID(leaderChoiceGUID).call("claimLeaderCall",
                                                     varToPass)
        end
    end
end

----------Utiliy functions--------------

function getLengthTable(table) -- determine size of an unordered table (#Table always give 0)
    length = 0
    for _, element in pairs(table) do length = length + 1 end
    return length
end

function findAnElementIndexInArray(element, arrayOfElements) -- return index (or nil) of an element in an array (with distinct value)
    local elementOrder = {}
    for i, v in ipairs(arrayOfElements) do elementOrder[v] = i end
    return elementOrder[element]
end

function cyclicIterator(first, Array) -- iterator that cycles through an entire array starting from any index
    i = -1
    return function() -- see closure + make your own iterator
        i = i + 1
        if i < #Array then
            return Array[(i + first - 1) % (#Array) + 1]
        else
            return nil
        end
    end
end

function findMissingElements(Array, ArrayWithMissingElement) -- used to compare find missing player color in 3 player game
    local A = {}
    local MissingElements = {}
    for _, element in ipairs(ArrayWithMissingElement) do A[element] = true end
    for _, element in ipairs(Array) do
        if A[element] == nil then table.insert(MissingElements, element) end
    end
    return MissingElements
end

function removeAnElementInArray(elementToDelete, arrayOfElements)
    for i, element in ipairs(arrayOfElements) do
        if element == elementToDelete then
            table.remove(arrayOfElements, i)
            return arrayOfElements
        end
    end
end
-----------------End section------------------------

function getPlayersBasedOnHotseat()
    local players = nil

    if hotseat_mode then
        -- TODO Of course not!
        players = {'Red', 'Blue', 'Green', 'Yellow'}
    else
        players = getSeatedPlayers()
    end

    return players

end

return hiddenPickModule
