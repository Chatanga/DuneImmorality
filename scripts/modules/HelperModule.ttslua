local helperModule = {}

constants = require("Constants")

drawDeckZone = constants.drawDeckZone

discardZone = constants.discardZone

drawSpot = constants.drawSpot

function helperModule.DrawOne(_, color)
    local starterDeck = helperModule.GetDeckOrCard(drawDeckZone[color])
    local discardFound = false

    if starterDeck ~= nil then
        starterDeck.deal(1, color)
    else
        discardFound = helperModule.ResetDiscard(_, color)
        if discardFound then
            Wait.time(function()
                local drawDeck = helperModule.GetDeckOrCard(drawDeckZone[color])
                drawDeck.deal(1, color)
            end, 1.5)
        else
            broadcastToColor("Missing one card to draw because your discard is empty", color, color)
        end
    end
    return discardFound
end

function helperModule.ResetDiscard(_, color)
    discardArea = helperModule.GetDeckOrCard(discardZone[color])
    local discardFound = true
    if discardArea ~= nil then
        discardArea.setRotationSmooth({0, 180, 180}, false, false)
        discardArea.shuffle()
        discardArea.setPositionSmooth(drawSpot[color], false, true)
        Wait.time(function()
            helperModule.GetDeckOrCard(drawDeckZone[color]).shuffle()
        end, 0.5)
    else
        discardFound = false
    end

    return discardFound

end

function helperModule.GetDeckOrCard(zoneGUID)
    for _, obj in ipairs(getObjectFromGUID(zoneGUID).getObjects()) do
        if obj.type == "Card" or obj.type == "Deck" then return obj end
    end
    log(zoneGUID .. " contains no card nor deck!")
    return nil
end

function helperModule.isDeckContainsEnough(color, numberToDraw)

    local starterDeck = helperModule.GetDeckOrCard(drawDeckZone[color])

    local enoughCards = true

    if starterDeck == nil then
        enoughCards = false
    else
        local countCheck = starterDeck.getQuantity()
        local typeCheck = starterDeck.type

        if typeCheck == "Card" then countCheck = 1 end

        if countCheck < numberToDraw then enoughCards = false end
    end

    return enoughCards
end

--FF-- Légèrement au dessus pour éviter de déplacer un objet un dessous (et
-- ajouter la destination à la source plutôt que l’inverse).
function helperModule.getLandingPosition(anchorGUID)
   local pos = getObjectFromGUID(anchorGUID).getPosition()
   return {pos[1], pos[2] + 0.1, pos[3]}
end

--FF--
function helperModule.addVector3D(left, right)
   return {left[1] + right[1], left[2] + right[2], left[3] + right[3]}
end

--FF-- Les nouvelles ancres ont toutes une échelle unitaire, ce qui n’était pas
-- le cas des anciennes.
function helperModule.correctAnchorPosition(pos, originalScale)
   return {pos[1] * originalScale[1], pos[2] * originalScale[2], pos[3] * originalScale[3]}
end

return helperModule
