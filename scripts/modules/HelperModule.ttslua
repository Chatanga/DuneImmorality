local helper = {}

core = require("Core")

constants = require("Constants")

parkModule = require("ParkModule")

--[[

drawIntrigue(color)
tryDrawCards(color, count, message)
drawCards(color, count)
resetDiscard(color)
getCardCount(deckZone)

moveCardFromZone(zone, position, rotation, smooth, flipAtTheEnd)
moveCardFromZoneGUID(zoneGUID, position, rotation, smooth)

getDeckOrCard(zone)
getDeck(zone)
getCard(zone)
getDeckOrCardFromGUID(zoneGUID)
getDeckFromGUID(zoneGUID)
getCardFromGUID(zoneGUID)

createRelativeSnapPointFromZone(zone, rotationSnap, tags)
createAbsoluteButton(object, parameters)
createAbsoluteAcquireButton(zone, zFactor, altitude, action, postParameters)
createAbsoluteButtonWithRoundness(object, roundness, quirk, parameters)

getPlayerTextColors(color)
getPlayer(color)
hasPlayer(color)
startPlayerAction(color)

getLeader(color)
getLeaderName(color)

landTroopsFromOrbit(color, count)
sendTroopsBackToOrbit(color, troops)
getTroopsFromOrbit(color)
grantTechTile(color, techTile)
getScoreTokens(color)
grantScoreToken(color, token)
grantScoreTokenFromBag(color, tokenBag)
getPlayerScore(color)
hasTech(color, techName)
hasACouncilSeat(color)
payResource(color, resourceName, amount)
gainResource(color, resourceName, amount)
getSpecimenCount(color)
hasReachedOneHelix(color)
hasReachedTwoHelices(color)
getDreadnoughtRestingPosition(dreadnoughName)

setSharedTable(tableName, table)
getSharedTable(tableName)
toCamelCase(...)
ToCamelCase(...)
toVector(data)
repeatMovingAction(object, action, count)
sleep(duration)
createContinuation()

]]--

function self.doNothing() end

function helper.drawIntrigue(color)
    local cardCount = 1

    local leaderName = helper.getLeaderName(color)
    if leaderName == "Count Fenring" then
        cardCount = 2
        Wait.time(function()
            broadcastToAll(leaderName .. i18n("fenring"), "Purple")
        end, 0.5)
    end

    Wait.time(function()
        -- Add an offset to put the card on the left side.
        local position = Player[color].getHandTransform().position + Vector(-7.5, 0, 0)
        helper.moveCardFromZone(constants.intrigue.deckZone, position, false, false, true)
        -- Same as dealToColorWithOffset(Vector(-7.5, 0, 0), true, color)?
    end, 0.25, cardCount)
end

function helper.tryDrawCards(color, count, message)
    local player = constants.players[color]
    local needDiscardReset = helper.getCardCount(player.drawDeckZone) < count
    local notEnoughCards =  helper.getCardCount(player.drawDeckZone) + helper.getCardCount(player.discardZone) < count

    if needDiscardReset or notEnoughCards < count then
        local leaderName = helper.getLeaderName(color)
        broadcastToAll(i18n("isDecidingToDraw"):format(leaderName), "Pink")
        local counter = i18n.translateCountable(count, "card", "cards")
        Player[color].showConfirmDialog(
            i18n("warningBeforeDraw"):format(count, counter),
            function(_)
                if message then
                    broadcastToAll(message, color)
                end
                helper.drawCards(color, count)
            end)
    else
        helper.drawCards(color, count)
    end
end

function helper.drawCards(color, count)
    local remainingCardToDrawCount = count

    local deckOrCard = helper.getDeckOrCard(constants.players[color].drawDeckZone)
    if deckOrCard then
        local drawableCardCount = deckOrCard.getQuantity()

        local dealCardCount = math.max(remainingCardToDrawCount, drawableCardCount)
        deckOrCard.deal(dealCardCount, color)

        remainingCardToDrawCount = remainingCardToDrawCount - dealCardCount

        if remainingCardToDrawCount > 0 then
            local reset = helper.resetDiscard(color)
            if reset then
                reset.doAfter(function(_)
                    helper.drawCards(color, remainingCardToDrawCount)
                end)
            end
        end
    end
end

function helper.resetDiscard(color)
    local player = constants.players[color]
    local discard = helper.getDeckOrCard(player.discardZone)
    if discard then
        local continuation = helper.createContinuation()

        discard.setRotationSmooth({0, 180, 180}, false, false)
        discard.setPositionSmooth(constants.getLandingPosition(player.drawDeckZone), false, true)

        Wait.time(function() -- Once moved.
            local replenishedDeckOrCard = helper.getDeckOrCard(player.drawDeckZone)
            assert(replenishedDeckOrCard)
            if replenishedDeckOrCard.type == "Deck" then
                replenishedDeckOrCard.shuffle()
                Wait.time(function () -- Once shuffled.
                    continuation.run(replenishedDeckOrCard)
                end, 1.5)
            else
                continuation.run(replenishedDeckOrCard)
            end
        end, 0.5)

        return continuation
    else
        return nil
    end
end

function helper.getCardCount(deckZone)
    local deckOrCard = helper.getDeckOrCard(deckZone)
    if not deckOrCard then
        return 0
    elseif deckOrCard.type == "Card" then
        return 1
    elseif deckOrCard.type == "Deck" then
        return deckOrCard.getQuantity()
    else
        return 0
    end
end

-- Prefer the "deal" method when possible.
function helper.moveCardFromZone(zone, position, rotation, smooth, flipAtTheEnd)
    local deckOrCard = helper.getDeckOrCard(zone)
    if deckOrCard then
        if deckOrCard.type == "Deck" then
            local parameters = {
                position = position,
                callback_function = function (card)
                    if flipAtTheEnd then
                        card.flip()
                    end
                end
            }
            if rotation then
                parameters.rotation = rotation
            end
            parameters.smooth = smooth or false
            deckOrCard.takeObject(parameters)
            return true
        elseif deckOrCard.type == "Card" then
            if smooth then
                deckOrCard.setPositionSmooth(position)
            else
                deckOrCard.setPosition(position)
            end
            if rotation then
                if smooth then
                    deckOrCard.setRotationSmooth(rotation)
                else
                    deckOrCard.setRotation(rotation)
                end
            end
            Wait.time(function() -- Once moved and rotated.
                deckOrCard.flip()
            end, 0.2)
            return true
        else
            assert(false)
        end
    end
    return false
end

function helper.moveCardFromZoneGUID(zoneGUID, position, rotation, smooth)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.moveCardFromZone(zone, position, rotation, smooth)
end

function helper.getDeckOrCard(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Card" or obj.type == "Deck" then return obj end
    end
    --log(zone.getGUID() .. " contains no card nor deck!")
    return nil
end

function helper.getDeck(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Deck" then return obj end
    end
    return nil
end

function helper.getCard(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Card" then return obj end
    end
    return nil
end

function helper.getDeckOrCardFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.getDeckOrCard(zone)
end

function helper.getDeckFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.getDeck(zone)
end

function helper.getCardFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.getCard(zone)
end

--[[
    Create a snapPoint relative to self centered on the provided zone but at the
    height of self.
]]--
function helper.createRelativeSnapPointFromZone(zone, rotationSnap, tags)
    local position = zone.getPosition()
    position:setAt("y", self.getPosition().y)
    local snapPoint = {
        position = self.positionToLocal(position),
        rotation_snap = rotationSnap,
        tags = tags
    }
    return snapPoint
end

--[[
    Indirect call to createButton adjusting the provided parameters to
    counteract the position, scale and rotation of the parent object.
    TTS does offer a positionToLocal method, but which only accounts for
    the position and (partly to the) scale, not the rotation. The
    convention for the world coordinates is a bit twisted here since the
    X coordinate is inverted.
]]--
function helper.createAbsoluteButton(object, parameters)
    helper.createAbsoluteButtonWithRoundness(object, 0.25, true, parameters)
end

function helper.createAbsoluteAcquireButton(zone, zFactor, altitude, action, postParameters)
    local position = zone.getPosition()
    local scale = zone.getScale()
    position.y = position.y - scale.y / 2 + altitude
    position.z = position.z + scale.z / 2 * zFactor

    local parameters = {
        click_function = action,
        function_owner = self,
        label = i18n("acquireButton"),
        position = position,
        width = 600,
        height = 200,
        font_size = 150,
        color = {0.25, 0.25, 0.25, 1},
        font_color = {1, 1, 1, 1}
    }

    if postParameters then
        for key, value in pairs(postParameters) do
            parameters[key] = value
        end
    end

    helper.createAbsoluteButtonWithRoundness(self, 0.75, false, parameters)
end

function helper.createAbsoluteButtonWithRoundness(object, roundness, quirk, parameters)
    local scale = object.getScale()
    local invScale = Vector(1 / scale.x, 1 / scale.y, 1 / scale.z)

    -- Only to counteract the absolute roundness of the background.
    local rescale = 1 / roundness

    local p = helper.toVector(parameters['position'])
    if p then
        -- Inverting the X coordinate comes from our global 180° rotation around Y.
        -- TODO Get rid of this quirk.
        if quirk then
            p = Vector(-p.x, p.y, p.z)
        else
            p = Vector(p.x, p.y, p.z)
        end

        p = p - object.getPosition()

        if quirk then
            p = Vector(p.x, p.y, p.z)
        else
            p = Vector(-p.x, p.y, p.z)
        end

        p:scale(invScale)

        -- Proper order?
        local r = object.getRotation()
        p:rotateOver('x', -r.x)
        p:rotateOver('y', -r.y)
        p:rotateOver('z', -r.z)

        parameters['position'] = p
    end

    local s = helper.toVector(parameters['scale'])
    if not s then
        s = Vector(1, 1, 1)
    end
    s = s * invScale * (1 / rescale)
    parameters['scale'] = s

    local w = parameters['width']
    if not w then
        w = 1
    end
    w = w * rescale
    parameters['width'] = w

    local h = parameters['height']
    if not h then
        h = 1
    end
    h = h * rescale
    parameters['height'] = h

    local font_size = parameters['font_size']
    if not font_size then
        font_size = 1
    end
    font_size = font_size * rescale
    parameters['font_size'] = font_size

    object.createButton(parameters)
end

function helper.getPlayerTextColors(color)

    local background = {0, 0, 0, 1}
    local foreground = {1, 1, 1, 1}

    if color == 'Green' then
        background = {0.192, 0.701, 0.168, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    elseif color == 'Yellow' then
        background = {0.9058, 0.898, 0.1725, 1}
        foreground = {0, 0, 0, 1}
    elseif color == 'Blue' then
        background = {0.118, 0.53, 1, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    elseif color == 'Red' then
        background =  {0.856, 0.1, 0.094, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    end

    return {
        bg = background,
        fg = foreground
    }
end

function helper.getPlayer(color)
    local player = constants.players[color]
    assert(player, "Unknow player color: " .. tostring(color))
    return player
end

function helper.hasPlayer(color)
    return constants.players[color] ~= nil
end

-- Typical preamble for any player action.
-- The calling object must provide the typical "activateButtons" function.
function helper.startPlayerAction(color)
    assert(activateButtons, "An activateButtons function must be provided by the caller.")

    if color ~= "Red" and color ~= "Blue" and color ~= "Green" and color ~= "Yellow" then
        broadcastToColor(i18n("noTouch"), color, "Pink")
        return false
    end

    -- Inhibit all buttons.
    self.clearButtons()
    Wait.time(activateButtons, 1)

    return true
end

function helper.getLeader(color)
    local leaderZone = helper.getPlayer(color).leader_zone
    for _, object in ipairs(leaderZone.getObjects()) do
        if object.hasTag("Leader") then
            return object
        end
    end
    return nil
end

function helper.getLeaderName(color)
    local leader = helper.getLeader(color)
    if leader then
        return leader.getName()
    else
        log(color .. " player has no leader")
        return "?"
    end
end

function helper.landTroopsFromOrbit(color, count)
    constants.structure.main.board.call("landTroopsFromOrbit", {color, count})
end

function helper.sendTroopsBackToOrbit(color, troops)
    constants.structure.main.board.call("sendTroopsBackToOrbit", {color, troops})
end

function helper.getTroopsFromOrbit(color)
    return constants.structure.main.board.call("getTroopsFromOrbit", color)
end

function helper.grantTechTile(color, techTile)
    local playerBoard = helper.getPlayer(color).board
    local techPark = playerBoard.call("getTechPark")
    parkModule.putObject(techTile, techPark)
end

function helper.getScoreTokens(color)
    local playerBoard = helper.getPlayer(color).board
    local scorePark = playerBoard.call("getScorePark")
    return parkModule.getObjects(scorePark)
end

function helper.grantScoreToken(color, token)
    local playerBoard = helper.getPlayer(color).board
    local scorePark = playerBoard.call("getScorePark")
    parkModule.putObject(token, scorePark)
end

function helper.grantScoreTokenFromBag(color, tokenBag)
    local playerBoard = helper.getPlayer(color).board
    local scorePark = playerBoard.call("getScorePark")
    parkModule.putObjectFromBag(tokenBag, scorePark)
end

function helper.getPlayerScore(color)
    local playerBoard = helper.getPlayer(color).board
    return playerBoard.call("getScore")
end

function helper.hasTech(color, techName)
    local techs = constants.players[color].techZone.getObjects()
    for _, tech in ipairs(techs) do
        if tech.hasTag(techName) then
            return true
        end
    end
    return false
end

function helper.hasACouncilSeat(color)
    for _, object in ipairs(constants.structure.main.councilZone.getObjects()) do
        if object.getName() == color .. " Councilor" then
            return true
        end
    end
    return false
end

function helper.payResource(color, resourceName, amount)
    local playerResource = constants.players[color][resourceName]
    if playerResource.call("collectVal") < amount then
        broadcastToColor(i18n(helper.toCamelCase("no", resourceName)), color, color)
        return false
    else
        Wait.time(function()
                playerResource.call("decrementVal")
            end, 0.35, amount)
        return true
    end
end

function helper.gainResource(color, resourceName, amount)
    local playerResource = constants.players[color][resourceName]
    Wait.time(function()
            playerResource.call("incrementVal")
        end, 0.35, amount)
end

function helper.getSpecimenCount(color)
    return constants.structure.immortality.board.call("getSpecimenCount", color)
end

function helper.hasReachedOneHelix(color)
    return constants.structure.immortality.board.call("hasReachedOneHelix", color)
end

function helper.hasReachedTwoHelices(color)
    return constants.structure.immortality.board.call("hasReachedTwoHelices", color)
end

function helper.getDreadnoughtRestingPosition(dreadnoughName)
    return constants.structure.main.makerAndRecall.call("getDreadnoughtRestingPosition", dreadnoughName)
end

function helper.setSharedTable(tableName, table)
    constants.structure.main.board.setTable(tableName, table)
end

function helper.getSharedTable(tableName)
    return constants.structure.main.board.getTable(tableName)
end

function helper.toCamelCase(...)
    local chameauString = ""
    for _, str in ipairs(arg) do
        chameauString = chameauString .. str:gsub("^%l", string.upper)
    end
    return chameauString
end

function helper.ToCamelCase(...)
    local dromadaireString = ""
    for _, str in ipairs(arg) do
        dromadaireString = dromadaireString .. str:gsub("^%l", string.upper)
    end
    return dromadaireString
end

function helper.toVector(data)
    if not data then
        log("nothing to vectorize")
        return Vector(0, 0, 0)
    elseif core.isSomeKindOfObject(data) then
        return data
    else
        return Vector(data[1], data[2], data[3])
    end
end

function helper.repeatMovingAction(object, action, count)
    if count > 0 then
        action()
        Wait.condition(function()
                helper.repeatMovingAction(object, action, count - 1)
            end, function()
                -- Or resting?
                return not object.isSmoothMoving()
            end)
    end
end

-- Intended to be used in a coroutine.
function helper.sleep(duration)
    local Time = os.clock() + duration
    while os.clock() < Time do
        coroutine.yield()
    end
end

function helper.createContinuation()
    local continuation = {}

    continuation.actions = {}

    continuation.doAfter = function (action)
        table.insert(continuation.actions, action)
    end

    continuation.run = function (parameters)
        for _, action in ipairs(continuation.actions) do
            action(parameters)
        end
    end

    return continuation
end

return helper
