local helper = {}

core = require("Core")

constants = require("Constants")

parkModule = require("ParkModule")

function helper.DrawOne(_, color)
    local starterDeck = helper.GetDeckOrCard(constants.players[color].drawDeckZone)
    local discardFound = false

    if starterDeck ~= nil then
        starterDeck.deal(1, color)
    else
        discardFound = helper.ResetDiscard(_, color)
        if discardFound then
            Wait.time(function()
                local drawDeck = helper.GetDeckOrCard(constants.players[color].drawDeckZone)
                drawDeck.deal(1, color)
            end, 1.5)
        else
            broadcastToColor("Missing one card to draw because your discard is empty", color, color)
        end
    end
    return discardFound
end

function helper.DrawCards(numberToDraw, color, message)
    assert(numberToDraw > 0)

    local enoughCards = helper.isDeckContainsEnough(color, numberToDraw)
    if not enoughCards then

        local leaderName = helper.getLeaderName(color)
        broadcastToAll(i18n("isDecidingToDraw"):format(leaderName), "Pink")

        local card = i18n("cards")
        if numberToDraw == 1 then
            card = i18n("card")
        end

        Player[color].showConfirmDialog(
            i18n("warningBeforeDraw"):format(numberToDraw, card),

            function(_)
                if message then
                    broadcastToAll(message, color)
                end
                for i = 0, numberToDraw - 1, 1 do
                    Wait.time(function()
                        DrawOne(_, color)
                    end, i)
                end
            end)
    else
        for i = 1, numberToDraw do
            Wait.time(function() DrawOne(_, color) end, i)
        end
    end
end

function helper.ResetDiscard(_, color)
    discardArea = helper.GetDeckOrCard(constants.players[color].discardZone)
    local discardFound = true
    if discardArea ~= nil then
        discardArea.setRotationSmooth({0, 180, 180}, false, false)
        discardArea.shuffle()
        discardArea.setPositionSmooth(constants.getLandingPosition(constants.players[color].drawDeckZone), false, true)
        Wait.time(function()
            helper.GetDeckOrCard(constants.players[color].drawDeckZone).shuffle()
        end, 0.5)
    else
        discardFound = false
    end

    return discardFound

end

function helper.GetDeckOrCard(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Card" or obj.type == "Deck" then return obj end
    end
    --log(zone.getGUID() .. " contains no card nor deck!")
    return nil
end

function helper.GetDeck(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Deck" then return obj end
    end
    return nil
end

function helper.GetCard(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Card" then return obj end
    end
    return nil
end

function helper.GetDeckOrCardFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.GetDeckOrCard(zone)
end

function helper.GetDeckFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.GetDeck(zone)
end

function helper.GetCardFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.GetCard(zone)
end

function helper.drawCard(zone, position, rotation, smooth)
    local deckOrCard = helper.GetDeckOrCard(zone)
    if deckOrCard then
        if deckOrCard.type == "Deck" then
            local parameters = {
                position = position
            }
            if rotation then
                parameters.rotation = rotation
            end
            parameters.smooth = smooth or false
            deckOrCard.takeObject(parameters)
            return true
        elseif deckOrCard.type == "Card" then
            if smooth then
                deckOrCard.setPositionSmooth(position)
            else
                deckOrCard.setPosition(position)
            end
            if rotation then
                if smooth then
                    deckOrCard.setRotationSmooth(rotation)
                else
                    deckOrCard.setRotation(rotation)
                end
            end
            return true
        end
    end
    return false
end

function helper.drawCardFromGUID(zoneGUID, position, rotation, smooth)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.drawCard(zone, position, rotation, smooth)
end

function helper.isDeckContainsEnough(color, numberToDraw)

    local starterDeck = helper.GetDeckOrCard(constants.players[color].drawDeckZone)

    local enoughCards = true

    if starterDeck == nil then
        enoughCards = false
    else
        local countCheck = starterDeck.getQuantity()
        local typeCheck = starterDeck.type

        if typeCheck == "Card" then countCheck = 1 end

        if countCheck < numberToDraw then enoughCards = false end
    end

    return enoughCards
end

-- Les nouvelles ancres ont toutes une échelle unitaire, ce qui n’était pas le
-- cas des anciennes.
function helper.correctAnchorPosition(pos, originalScale)
    return Vector(
        pos[1] * originalScale[1],
        pos[2] * originalScale[2],
        pos[3] * originalScale[3])
end

function helper.getPlayerTextColors(playerColor)

    local background = {0, 0, 0, 1}
    local foreground = {1, 1, 1, 1}

    if playerColor == 'Green' then
        background = {0.192, 0.701, 0.168, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    elseif playerColor == 'Yellow' then
        background = {0.9058, 0.898, 0.1725, 1}
        foreground = {0, 0, 0, 1}
    elseif playerColor == 'Blue' then
        background = {0.118, 0.53, 1, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    elseif playerColor == 'Red' then
        background =  {0.856, 0.1, 0.094, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    end

    return {
        bg = background,
        fg = foreground
    }
end

function helper.toVector(data)
    if not data or core.isSomeKindOfObject(data) then
        return data
    else
        return Vector(data[1], data[2], data[3])
    end
end

function helper.createAbsoluteSnapPointFromZone(zone, rotationSnap, tags)
    local position = zone.getPosition()
    position:setAt("y", self.getPosition().y)
    local snapPoint = {
        position = self.positionToLocal(position),
        rotation_snap = rotationSnap,
        tags = tags
    }
    return snapPoint
end

--[[
    Indirect call to createButton adjusting the provided parameters to
    counteract the position, scale and rotation of the parent object.
    TTS does offer a positionToLocal method, but which only accounts for
    the position and (partly to the) scale, not the rotation. The
    convention for the world coordinates is a bit twisted here since the
    X coordinate is inverted.
]]--
function helper.createAbsoluteButton(object, parameters)
    helper.createAbsoluteButtonWithRoundness(object, 0.25, true, parameters)
end

function helper.createAbsoluteAcquireButton(zone, zFactor, altitude, action, postParameters)
    local position = zone.getPosition()
    local scale = zone.getScale()
    position.y = position.y - scale.y / 2 + altitude
    position.z = position.z + scale.z / 2 * zFactor

    local parameters = {
        click_function = action,
        function_owner = self,
        label = i18n("acquireButton"),
        position = position,
        width = 600,
        height = 200,
        font_size = 150,
        color = {0.25, 0.25, 0.25, 1},
        font_color = {1, 1, 1, 1}
    }

    if postParameters then
        for key, value in pairs(postParameters) do
            parameters[key] = value
        end
    end

    helper.createAbsoluteButtonWithRoundness(self, 0.75, false, parameters)
end

function helper.createAbsoluteButtonWithRoundness(object, roundness, quirk, parameters)
    local scale = object.getScale()
    local invScale = Vector(1 / scale.x, 1 / scale.y, 1 / scale.z)

    -- Only to counteract the absolute roundness of the background.
    local rescale = 1 / roundness

    local p = helper.toVector(parameters['position'])
    if p then
        -- Inverting the X coordinate comes from our global 180° rotation around Y.
        -- TODO Get rid of this quirk.
        if quirk then
            p = Vector(-p.x, p.y, p.z)
        else
            p = Vector(p.x, p.y, p.z)
        end

        p = p - object.getPosition()

        if quirk then
            p = Vector(p.x, p.y, p.z)
        else
            p = Vector(-p.x, p.y, p.z)
        end

        p:scale(invScale)

        -- Proper order?
        local r = object.getRotation()
        p:rotateOver('x', -r.x)
        p:rotateOver('y', -r.y)
        p:rotateOver('z', -r.z)

        parameters['position'] = p
    end

    local s = helper.toVector(parameters['scale'])
    if not s then
        s = Vector(1, 1, 1)
    end
    s = s * invScale * (1 / rescale)
    parameters['scale'] = s

    local w = parameters['width']
    if not w then
        w = 1
    end
    w = w * rescale
    parameters['width'] = w

    local h = parameters['height']
    if not h then
        h = 1
    end
    h = h * rescale
    parameters['height'] = h

    local font_size = parameters['font_size']
    if not font_size then
        font_size = 1
    end
    font_size = font_size * rescale
    parameters['font_size'] = font_size

    object.createButton(parameters)
end

-- Typical preamble for any player action.
-- The calling object must provide the typical "activateButtons" function.
function helper.startPlayerAction(playerColor)
    assert(activateButtons, "An activateButtons function must be provided by the caller.")

    if playerColor ~= "Red" and playerColor ~= "Blue" and playerColor ~= "Green" and playerColor ~= "Yellow" then
        broadcastToColor(i18n("noTouch"), playerColor, "Pink")
        return false
    end

    -- Inhibit all buttons.
    self.clearButtons()
    Wait.time(activateButtons, 1)

    return true
end

function helper.getLeader(playerColor)
    local leaderZone = helper.getPlayer(playerColor).leader_zone
    for _, object in ipairs(leaderZone.getObjects()) do
        if object.hasTag("Leader") then
            return object
        end
    end
    return nil
end

function helper.getLeaderName(playerColor)
    local leader = helper.getLeader(playerColor)
    if leader then
        return leader.getName()
    else
        log(playerColor .. " player has no leader")
        return "?"
    end
end

function helper.landTroopsFromOrbit(playerColor, count)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.call("landTroopsFromOrbit", {playerColor, count})
end

function helper.sendTroopsBackToOrbit(playerColor, troops)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.call("sendTroopsBackToOrbit", {playerColor, troops})
end

function helper.getTroopsFromOrbit(playerColor)
    local mainBoard = getObjectFromGUID('2da390')
    return mainBoard.call("getTroopsFromOrbit", playerColor)
end

function helper.grantTechTile(playerColor, techTile)
    local playerBoard = helper.getPlayer(playerColor).board
    local techPark = playerBoard.call("getTechPark")
    parkModule.putObject(techTile, techPark)
end

function helper.getScoreTokens(playerColor)
    local playerBoard = helper.getPlayer(playerColor).board
    local scorePark = playerBoard.call("getScorePark")
    return parkModule.getObjects(scorePark)
end

function helper.grantScoreToken(playerColor, token)
    local playerBoard = helper.getPlayer(playerColor).board
    local scorePark = playerBoard.call("getScorePark")
    parkModule.putObject(token, scorePark)
end

function helper.grantScoreTokenFromBag(playerColor, tokenBag)
    local playerBoard = helper.getPlayer(playerColor).board
    local scorePark = playerBoard.call("getScorePark")
    parkModule.putObjectFromBag(tokenBag, scorePark)
end

function helper.getPlayerScore(playerColor)
    local playerBoard = helper.getPlayer(playerColor).board
    return playerBoard.call("getScore")
end

function helper.getPlayer(playerColor)
    local player = constants.players[playerColor]
    assert(player, "Unknow player color: " .. tostring(playerColor))
    return player
end

function helper.hasPlayer(playerColor)
    return constants.players[playerColor] ~= nil
end

function helper.hasTech(playerColor, techName)
    local techs = constants.players[playerColor].techZone.getObjects()
    for _, tech in ipairs(techs) do
        if tech.hasTag(techName) then
            return true
        end
    end
    return false
end

-- TODO Rework
function helper.getSpecimenCount(color)
    local zone = getObjectFromGUID("f5de09")
    local specimenCount = 0
    for _, troop in ipairs(zone.getObjects()) do
        if troop.hasTag("Troop") and troop.hasTag(color) then
            specimenCount = specimenCount + 1
        end
    end
    return specimenCount
end

-- TODO Rework
function helper.hasReachedResearchLevelOne(color)
    local scriptZone_middleTrack_research = getObjectFromGUID("60a0fd")
    local objs = scriptZone_middleTrack_research.getObjects()
    for _, item in ipairs(objs) do
        if item.hasTag(color) then
            return true
        end
    end
    return false
end

function helper.getDreadnoughtRestingPosition(dreadnoughName)
    local makerAndRecall = getObjectFromGUID('120026')
    return makerAndRecall.call("getDreadnoughtRestingPosition", dreadnoughName)
end

function helper.setSharedTable(tableName, table)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.setTable(tableName, table)
end

function helper.getSharedTable(tableName)
    local mainBoard = getObjectFromGUID('2da390')
    return mainBoard.getTable(tableName)
end

return helper
