local helperModule = {}

constants = require("Constants")

parkModule = require("ParkModule")

function helperModule.DrawOne(_, color)
    local starterDeck = helperModule.GetDeckOrCard(constants.players[color].drawDeckZone)
    local discardFound = false

    if starterDeck ~= nil then
        starterDeck.deal(1, color)
    else
        discardFound = helperModule.ResetDiscard(_, color)
        if discardFound then
            Wait.time(function()
                local drawDeck = helperModule.GetDeckOrCard(constants.players[color].drawDeckZone)
                drawDeck.deal(1, color)
            end, 1.5)
        else
            broadcastToColor("Missing one card to draw because your discard is empty", color, color)
        end
    end
    return discardFound
end

function helperModule.ResetDiscard(_, color)
    discardArea = helperModule.GetDeckOrCard(constants.players[color].discardZone)
    local discardFound = true
    if discardArea ~= nil then
        discardArea.setRotationSmooth({0, 180, 180}, false, false)
        discardArea.shuffle()
        discardArea.setPositionSmooth(constants.getLandingPosition(constants.players[color].drawDeckZone), false, true)
        Wait.time(function()
            helperModule.GetDeckOrCard(constants.players[color].drawDeckZone).shuffle()
        end, 0.5)
    else
        discardFound = false
    end

    return discardFound

end

function helperModule.GetDeckOrCard(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Card" or obj.type == "Deck" then return obj end
    end
    --log(zone.getGUID() .. " contains no card nor deck!")
    return nil
end

function helperModule.GetDeckOrCardFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local object = getObjectFromGUID(zoneGUID)
    assert(object, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helperModule.GetDeckOrCard(object)
end

function helperModule.isDeckContainsEnough(color, numberToDraw)

    local starterDeck = helperModule.GetDeckOrCard(constants.players[color].drawDeckZone)

    local enoughCards = true

    if starterDeck == nil then
        enoughCards = false
    else
        local countCheck = starterDeck.getQuantity()
        local typeCheck = starterDeck.type

        if typeCheck == "Card" then countCheck = 1 end

        if countCheck < numberToDraw then enoughCards = false end
    end

    return enoughCards
end

-- Les nouvelles ancres ont toutes une échelle unitaire, ce qui n’était pas le
-- cas des anciennes.
function helperModule.correctAnchorPosition(pos, originalScale)
    return Vector(
        pos[1] * originalScale[1],
        pos[2] * originalScale[2],
        pos[3] * originalScale[3])
end

function helperModule.getPlayerTextColors(playerColor)

    local background = {0, 0, 0, 1}
    local foreground = {1, 1, 1, 1}

    if playerColor == 'Green' then
        background = {0.192, 0.701, 0.168, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    elseif playerColor == 'Yellow' then
        background = {0.9058, 0.898, 0.1725, 1}
        foreground = {0, 0, 0, 1}
    elseif playerColor == 'Blue' then
        background = {0.118, 0.53, 1, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    elseif playerColor == 'Red' then
        background =  {0.856, 0.1, 0.094, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    end

    return {
        bg = background,
        fg = foreground
    }
end

--[[
    Indirect call to createButton adjusting the provided parameters to
    counteract the position, scale and rotation of the parent object.
    TTS does offer a positionToLocal method, but which only accounts for
    the position and (partly to the) scale, not the rotation. The
    convention for the world coordinates is a bit twisted here since the
    X coordinate is inverted.
]]--
function helperModule.createAbsoluteButton(object, parameters)
    local scale = object.getScale()
    local invScale = Vector(1 / scale.x, 1 / scale.y, 1 / scale.z)

    -- Only to counteract the absolute roundness of the background.
    local rescale = 4

    local p = parameters['position']
    if p then
        -- Inverting the X coordinate comes from our global 180° rotation around Y.
        p = Vector(-p.x, p.y, p.z)

        p = p - object.getPosition()

        p:scale(invScale)

        -- Proper order?
        local r = object.getRotation()
        p:rotateOver('x', -r.x)
        p:rotateOver('y', -r.y)
        p:rotateOver('z', -r.z)

        parameters['position'] = p
    end

    local s = parameters['scale']
    if not s then
        s= Vector(1, 1, 1)
    end
    s = s * invScale * (1 / rescale)
    parameters['scale'] = s

    local w = parameters['width']
    if not w then
        w = 1
    end
    w = w * rescale
    parameters['width'] = w

    local h = parameters['height']
    if not h then
        h = 1
    end
    h = h * rescale
    parameters['height'] = h

    local font_size = parameters['font_size']
    if not font_size then
        font_size = 1
    end
    font_size = font_size * rescale
    parameters['font_size'] = font_size

    object.createButton(parameters)
end

function helperModule.getLeader(playerColor)
    local leaderZone = helperModule.getPlayer(playerColor).leader_zone
    for _, object in ipairs(leaderZone.getObjects()) do
        if object.hasTag("Leader") then
            return object
        end
    end
    return nil
end

function helperModule.getLeaderName(playerColor)
    local leader = helperModule.getLeader(playerColor)
    if leader then
        return leader.getName()
    else
        log(playerColor .. " player has no leader")
        return "?"
    end
end

function helperModule.landTroopsFromOrbit(playerColor, count)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.call("landTroopsFromOrbit", {playerColor, count})
end

function helperModule.sendTroopsBackToOrbit(playerColor, troops)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.call("sendTroopsBackToOrbit", {playerColor, troops})
end

function helperModule.getTroopsFromOrbit(playerColor)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.call("getTroopsFromOrbit", playerColor)
end

function helperModule.getScoreTokens(playerColor)
    local playerBoard = helperModule.getPlayer(playerColor).board
    local scorePark = playerBoard.call("getScorePark")
    return parkModule.getObjects(scorePark)
end

function helperModule.grantScoreToken(playerColor, token)
    local playerBoard = helperModule.getPlayer(playerColor).board
    local scorePark = playerBoard.call("getScorePark")
    parkModule.putObject(token, scorePark)
end

function helperModule.grantScoreTokenFromBag(playerColor, tokenBag)
    local playerBoard = helperModule.getPlayer(playerColor).board
    local scorePark = playerBoard.call("getScorePark")
    parkModule.putObjectFromBag(tokenBag, scorePark)
end

function helperModule.getPlayerScore(playerColor)
    local playerBoard = helperModule.getPlayer(playerColor).board
    return playerBoard.call("getScore")
end

function helperModule.getPlayer(playerColor)
    local player = constants.players[playerColor]
    assert(player, "Unknow player color: " .. tostring(playerColor))
    return player
end

function helperModule.hasPlayer(playerColor)
    return constants.players[playerColor] ~= nil
end

function helperModule.setSharedTable(tableName, table)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.setTable(tableName, table)
end

function helperModule.getSharedTable(tableName)
    local mainBoard = getObjectFromGUID('2da390')
    return mainBoard.getTable(tableName)
end

return helperModule
