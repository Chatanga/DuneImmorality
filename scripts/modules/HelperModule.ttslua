local helper = {}

core = require("Core")

constants = require("Constants")

parkModule = require("ParkModule")

function helper.drawIntrigue(color)
    local cardCount = 1
    if helper.getLeaderName(color) == "Count Fenring" then
        cardCount = 2
        Wait.time(function()
            broadcastToAll(helper.getLeaderName(color) .. i18n("fenring"), "Purple")
        end, 0.5)
    end

    Wait.time(function()
        local handZone = Player[color].getHandTransform()
        local intrigueDeck = helper.getDeckOrCard(intrigue_zone)
        local position = handZone.position + Vector(-7.5, 0, 0)
        helper.moveCardFromZone(handZone, position, false, false, true)
    end, 0.25, cardCount)
end

function helper.drawOneCard(_, color)
    local drawDeck = helper.getDeckOrCard(constants.players[color].drawDeckZone)
    if drawDeck then
        drawDeck.deal(1, color)
        return true
    else
        if helper.resetDiscard(_, color) then
            Wait.time(function()
                local replenishedDrawDeck = helper.getDeckOrCard(constants.players[color].drawDeckZone)
                if replenishedDrawDeck then
                    replenishedDrawDeck.deal(1, color)
                end
            end, 1.5)
            return true
        else
            -- TODO Translate
            broadcastToColor("Missing one card to draw because your discard is empty", color, color)
            return false
        end
    end
end

function helper.drawCards(color, drawCount, message)
    assert(drawCount > 0)
    local enoughCards = helper.doesDeckContainEnoughCards(color, drawCount)
    if not enoughCards then

        local leaderName = helper.getLeaderName(color)
        broadcastToAll(i18n("isDecidingToDraw"):format(leaderName), "Pink")

        local counter = i18n.translateCountable(drawCount, "card", "cards")
        Player[color].showConfirmDialog(
            i18n("warningBeforeDraw"):format(drawCount, counter),
            function(_)
                if message then
                    broadcastToAll(message, color)
                end
                Wait.time(function()
                    helper.drawOneCard(_, color)
                end, 1, drawCount)
            end)
        return false
    else
        Wait.time(function()
            helper.drawOneCard(_, color)
        end, 1, drawCount)
        return true
    end
end

function helper.doesDeckContainEnoughCards(color, drawCound)
    local deckOrCard = helper.getDeckOrCard(constants.players[color].drawDeckZone)
    if not deckOrCard then
        return drawCound <= 0
    elseif deckOrCard.type == "Card" then
        return drawCound <= 1
    elseif deckOrCard.type == "Deck" then
        return drawCound <= deckOrCard.getQuantity()
    else
        return false
    end
end

function helper.resetDiscard(_, color)
    local discardZone = helper.getDeckOrCard(constants.players[color].discardZone)
    if discardZone then
        discardZone.setRotationSmooth({0, 180, 180}, false, false)
        discardZone.shuffle()
        discardZone.setPositionSmooth(constants.getLandingPosition(constants.players[color].drawDeckZone), false, true)
        Wait.time(function()
            helper.getDeckOrCard(constants.players[color].drawDeckZone).shuffle()
        end, 0.5)
        return true
    else
        return false
    end
end

function helper.getDeckOrCard(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Card" or obj.type == "Deck" then return obj end
    end
    --log(zone.getGUID() .. " contains no card nor deck!")
    return nil
end

function helper.getDeck(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Deck" then return obj end
    end
    return nil
end

function helper.getCard(zone)
    assert(zone)
    assert(type(zone) ~= 'string', tostring(zone) .. ' is a GUID, not a zone')
    for _, obj in ipairs(zone.getObjects()) do
        if obj.type == "Card" then return obj end
    end
    return nil
end

function helper.getDeckOrCardFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.getDeckOrCard(zone)
end

function helper.getDeckFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.getDeck(zone)
end

function helper.getCardFromGUID(zoneGUID)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.getCard(zone)
end

function helper.moveCardFromZone(zone, position, rotation, smooth, flipAtTheEnd)
    local deckOrCard = helper.getDeckOrCard(zone)
    if deckOrCard then
        if deckOrCard.type == "Deck" then
            local parameters = {
                position = position,
                callback_function = function (card)
                    if flipAtTheEnd then
                        card.flip()
                    end
                end
            }
            if rotation then
                parameters.rotation = rotation
            end
            parameters.smooth = smooth or false
            deckOrCard.takeObject(parameters)
            return true
        elseif deckOrCard.type == "Card" then
            if smooth then
                deckOrCard.setPositionSmooth(position)
            else
                deckOrCard.setPosition(position)
            end
            if rotation then
                if smooth then
                    deckOrCard.setRotationSmooth(rotation)
                else
                    deckOrCard.setRotation(rotation)
                end
            end
            Wait.time(function() deckOrCard.flip() end, 0.2)
            return true
        end
    end
    return false
end

function helper.moveCardFromZoneGUID(zoneGUID, position, rotation, smooth)
    assert(type(zoneGUID) == 'string', tostring(zoneGUID) .. ' is not a GUID')
    local zone = getObjectFromGUID(zoneGUID)
    assert(zone, "Failed to resolve GUID: " .. tostring(zoneGUID))
    return helper.moveCardFromZone(zone, position, rotation, smooth)
end

function helper.getPlayerTextColors(playerColor)

    local background = {0, 0, 0, 1}
    local foreground = {1, 1, 1, 1}

    if playerColor == 'Green' then
        background = {0.192, 0.701, 0.168, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    elseif playerColor == 'Yellow' then
        background = {0.9058, 0.898, 0.1725, 1}
        foreground = {0, 0, 0, 1}
    elseif playerColor == 'Blue' then
        background = {0.118, 0.53, 1, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    elseif playerColor == 'Red' then
        background =  {0.856, 0.1, 0.094, 1}
        foreground = {0.7804, 0.7804, 0.7804, 1}
    end

    return {
        bg = background,
        fg = foreground
    }
end

function helper.toVector(data)
    if not data or core.isSomeKindOfObject(data) then
        return data
    else
        return Vector(data[1], data[2], data[3])
    end
end

function helper.createAbsoluteSnapPointFromZone(zone, rotationSnap, tags)
    local position = zone.getPosition()
    position:setAt("y", self.getPosition().y)
    local snapPoint = {
        position = self.positionToLocal(position),
        rotation_snap = rotationSnap,
        tags = tags
    }
    return snapPoint
end

--[[
    Indirect call to createButton adjusting the provided parameters to
    counteract the position, scale and rotation of the parent object.
    TTS does offer a positionToLocal method, but which only accounts for
    the position and (partly to the) scale, not the rotation. The
    convention for the world coordinates is a bit twisted here since the
    X coordinate is inverted.
]]--
function helper.createAbsoluteButton(object, parameters)
    helper.createAbsoluteButtonWithRoundness(object, 0.25, true, parameters)
end

function helper.createAbsoluteAcquireButton(zone, zFactor, altitude, action, postParameters)
    local position = zone.getPosition()
    local scale = zone.getScale()
    position.y = position.y - scale.y / 2 + altitude
    position.z = position.z + scale.z / 2 * zFactor

    local parameters = {
        click_function = action,
        function_owner = self,
        label = i18n("acquireButton"),
        position = position,
        width = 600,
        height = 200,
        font_size = 150,
        color = {0.25, 0.25, 0.25, 1},
        font_color = {1, 1, 1, 1}
    }

    if postParameters then
        for key, value in pairs(postParameters) do
            parameters[key] = value
        end
    end

    helper.createAbsoluteButtonWithRoundness(self, 0.75, false, parameters)
end

function helper.createAbsoluteButtonWithRoundness(object, roundness, quirk, parameters)
    local scale = object.getScale()
    local invScale = Vector(1 / scale.x, 1 / scale.y, 1 / scale.z)

    -- Only to counteract the absolute roundness of the background.
    local rescale = 1 / roundness

    local p = helper.toVector(parameters['position'])
    if p then
        -- Inverting the X coordinate comes from our global 180Â° rotation around Y.
        -- TODO Get rid of this quirk.
        if quirk then
            p = Vector(-p.x, p.y, p.z)
        else
            p = Vector(p.x, p.y, p.z)
        end

        p = p - object.getPosition()

        if quirk then
            p = Vector(p.x, p.y, p.z)
        else
            p = Vector(-p.x, p.y, p.z)
        end

        p:scale(invScale)

        -- Proper order?
        local r = object.getRotation()
        p:rotateOver('x', -r.x)
        p:rotateOver('y', -r.y)
        p:rotateOver('z', -r.z)

        parameters['position'] = p
    end

    local s = helper.toVector(parameters['scale'])
    if not s then
        s = Vector(1, 1, 1)
    end
    s = s * invScale * (1 / rescale)
    parameters['scale'] = s

    local w = parameters['width']
    if not w then
        w = 1
    end
    w = w * rescale
    parameters['width'] = w

    local h = parameters['height']
    if not h then
        h = 1
    end
    h = h * rescale
    parameters['height'] = h

    local font_size = parameters['font_size']
    if not font_size then
        font_size = 1
    end
    font_size = font_size * rescale
    parameters['font_size'] = font_size

    object.createButton(parameters)
end

-- Typical preamble for any player action.
-- The calling object must provide the typical "activateButtons" function.
function helper.startPlayerAction(playerColor)
    assert(activateButtons, "An activateButtons function must be provided by the caller.")

    if playerColor ~= "Red" and playerColor ~= "Blue" and playerColor ~= "Green" and playerColor ~= "Yellow" then
        broadcastToColor(i18n("noTouch"), playerColor, "Pink")
        return false
    end

    -- Inhibit all buttons.
    self.clearButtons()
    Wait.time(activateButtons, 1)

    return true
end

function helper.getLeader(playerColor)
    local leaderZone = helper.getPlayer(playerColor).leader_zone
    for _, object in ipairs(leaderZone.getObjects()) do
        if object.hasTag("Leader") then
            return object
        end
    end
    return nil
end

function helper.getLeaderName(playerColor)
    local leader = helper.getLeader(playerColor)
    if leader then
        return leader.getName()
    else
        log(playerColor .. " player has no leader")
        return "?"
    end
end

function helper.toCamelCase(...)
    local chameauString = ""
    for i, str in ipairs(arg) do
        chameauString = chameauString .. str:gsub("^%l", string.upper)
    end
    return chameauString
end

function helper.ToCamelCase(...)
    local dromadaireString = ""
    for _, str in ipairs(arg) do
        dromadaireString = dromadaireString .. str:gsub("^%l", string.upper)
    end
    return dromadaireString
end

function helper.landTroopsFromOrbit(playerColor, count)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.call("landTroopsFromOrbit", {playerColor, count})
end

function helper.sendTroopsBackToOrbit(playerColor, troops)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.call("sendTroopsBackToOrbit", {playerColor, troops})
end

function helper.getTroopsFromOrbit(playerColor)
    local mainBoard = getObjectFromGUID('2da390')
    return mainBoard.call("getTroopsFromOrbit", playerColor)
end

function helper.grantTechTile(playerColor, techTile)
    local playerBoard = helper.getPlayer(playerColor).board
    local techPark = playerBoard.call("getTechPark")
    parkModule.putObject(techTile, techPark)
end

function helper.getScoreTokens(playerColor)
    local playerBoard = helper.getPlayer(playerColor).board
    local scorePark = playerBoard.call("getScorePark")
    return parkModule.getObjects(scorePark)
end

function helper.grantScoreToken(playerColor, token)
    local playerBoard = helper.getPlayer(playerColor).board
    local scorePark = playerBoard.call("getScorePark")
    parkModule.putObject(token, scorePark)
end

function helper.grantScoreTokenFromBag(playerColor, tokenBag)
    local playerBoard = helper.getPlayer(playerColor).board
    local scorePark = playerBoard.call("getScorePark")
    parkModule.putObjectFromBag(tokenBag, scorePark)
end

function helper.getPlayerScore(playerColor)
    local playerBoard = helper.getPlayer(playerColor).board
    return playerBoard.call("getScore")
end

function helper.getPlayer(playerColor)
    local player = constants.players[playerColor]
    assert(player, "Unknow player color: " .. tostring(playerColor))
    return player
end

function helper.hasPlayer(playerColor)
    return constants.players[playerColor] ~= nil
end

function helper.hasTech(playerColor, techName)
    local techs = constants.players[playerColor].techZone.getObjects()
    for _, tech in ipairs(techs) do
        if tech.hasTag(techName) then
            return true
        end
    end
    return false
end

-- TODO Rework
function helper.getSpecimenCount(color)
    local zone = getObjectFromGUID("f5de09")
    local specimenCount = 0
    for _, troop in ipairs(zone.getObjects()) do
        if troop.hasTag("Troop") and troop.hasTag(color) then
            specimenCount = specimenCount + 1
        end
    end
    return specimenCount
end

-- TODO Rework
function helper.hasReachedResearchLevelOne(color)
    local scriptZone_middleTrack_research = getObjectFromGUID("60a0fd")
    local objs = scriptZone_middleTrack_research.getObjects()
    for _, item in ipairs(objs) do
        if item.hasTag(color) then
            return true
        end
    end
    return false
end

function helper.getDreadnoughtRestingPosition(dreadnoughName)
    local makerAndRecall = getObjectFromGUID('120026')
    return makerAndRecall.call("getDreadnoughtRestingPosition", dreadnoughName)
end

function helper.setSharedTable(tableName, table)
    local mainBoard = getObjectFromGUID('2da390')
    mainBoard.setTable(tableName, table)
end

function helper.getSharedTable(tableName)
    local mainBoard = getObjectFromGUID('2da390')
    return mainBoard.getTable(tableName)
end

return helper
